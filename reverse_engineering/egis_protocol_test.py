#!/usr/bin/env python3
import usb.core
import usb.util
import time
import sys
from datetime import datetime

VENDOR = 0x1c7a
PRODUCT = 0x0576

# EH575 initialization sequences from libfprint driver
PRE_INIT_PACKETS = [
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x00, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x01, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0a, 0xfd],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x35, 0x02],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x80, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x80, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0a, 0xfc],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x01, 0x02, 0x0f, 0x03],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0c, 0x22],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x09, 0x83],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x26, 0x06, 0x06, 0x60, 0x06, 0x05, 0x2f, 0x06],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0a, 0xf4],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0c, 0x44],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x50, 0x03],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x50, 0x03],
    [0x45, 0x47, 0x49, 0x53, 0x73, 0x14, 0xec],  # This one expects large response
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x40, 0xec],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x09, 0x0b, 0x83, 0x24, 0x00, 0x44, 0x0f, 0x08, 0x20, 0x20, 0x01, 0x05, 0x12],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x26, 0x06, 0x06, 0x60, 0x06, 0x05, 0x2f, 0x06],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x23, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x24, 0x33],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x20, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x21, 0x66],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x00, 0x66],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x01, 0x66],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x40, 0x66],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0c, 0x22],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0b, 0x03],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x0a, 0xfc],
]

POST_INIT_PACKETS = [
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x00, 0xfc],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x01, 0xfc],  # Check response - if 01:01:01 then switch to PRE_INIT
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x40, 0xfc],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x09, 0x0b, 0x83, 0x24, 0x00, 0x44, 0x0f, 0x08, 0x20, 0x20, 0x01, 0x05, 0x12],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x26, 0x06, 0x06, 0x60, 0x06, 0x05, 0x2f, 0x06],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x23, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x24, 0x33],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x20, 0x00],
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x21, 0x66],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x00, 0x66],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x01, 0x66],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x2c, 0x02, 0x00, 0x57],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x2d, 0x02],
    [0x45, 0x47, 0x49, 0x53, 0x62, 0x67, 0x03],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x0f, 0x03],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x2c, 0x02, 0x00, 0x13],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x00, 0x02],
    [0x45, 0x47, 0x49, 0x53, 0x64, 0x14, 0xec],  # Expects large response (5356 bytes)
]

REPEAT_PACKETS = [
    [0x45, 0x47, 0x49, 0x53, 0x61, 0x2d, 0x20],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x00, 0x20],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x01, 0x20],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x2c, 0x02, 0x00, 0x57],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x2d, 0x02],
    [0x45, 0x47, 0x49, 0x53, 0x62, 0x67, 0x03],
    [0x45, 0x47, 0x49, 0x53, 0x63, 0x2c, 0x02, 0x00, 0x13],
    [0x45, 0x47, 0x49, 0x53, 0x60, 0x00, 0x02],
    [0x45, 0x47, 0x49, 0x53, 0x64, 0x14, 0xec],  # Expects large response (5356 bytes)
]

def connect_device():
    dev = usb.core.find(idVendor=VENDOR, idProduct=PRODUCT)
    if dev is None:
        print("âŒ Device not found")
        return None
    
    try:
        cfg = dev.get_active_configuration()
    except usb.core.USBError as e:
        print(f"âŒ Permission error: {e}")
        return None
    
    intf = cfg[(0,0)]
    if dev.is_kernel_driver_active(intf.bInterfaceNumber):
        print("ðŸ”Œ Detaching kernel driver...")
        dev.detach_kernel_driver(intf.bInterfaceNumber)
    usb.util.claim_interface(dev, intf.bInterfaceNumber)
    
    print("âœ… Device connected successfully")
    return dev, intf

def send_command(dev, data, endpoint=0x01):
    """Send command to device"""
    try:
        result = dev.write(endpoint, bytes(data), timeout=2000)
        cmd_str = ' '.join(f'{b:02x}' for b in data)
        print(f"ðŸ“¤ Sent: {cmd_str}")
        return result
    except Exception as e:
        print(f"âŒ Send failed: {e}")
        return None

def read_response(dev, endpoint=0x82, length=64, timeout=2000):
    """Read response from device"""
    try:
        data = dev.read(endpoint, length, timeout=timeout)
        resp_str = ' '.join(f'{b:02x}' for b in data)
        print(f"ðŸ“¥ Received ({len(data)} bytes): {resp_str}")
        return data
    except usb.core.USBError as e:
        if 'timeout' not in str(e).lower():
            print(f"âŒ Read error: {e}")
        return None

def try_packet_sequence(dev, packets, sequence_name):
    """Try a sequence of packets"""
    print(f"\n{'='*60}")
    print(f"ðŸš€ Trying {sequence_name} sequence ({len(packets)} packets)")
    print(f"{'='*60}")
    
    responses = []
    success_count = 0
    
    for i, packet in enumerate(packets):
        print(f"\n--- Packet {i+1}/{len(packets)} ---")
        
        # Send command
        if send_command(dev, packet) is None:
            continue
        
        # Read response (try different sizes for packets that expect large responses)
        if len(packet) > 7 and packet[4] in [0x73, 0x64]:  # Commands that expect large responses
            print("ðŸ“Š Expecting large response...")
            response = read_response(dev, length=6000, timeout=3000)
        else:
            response = read_response(dev, timeout=1000)
        
        if response:
            success_count += 1
            responses.append(response)
            
            # Save response to file
            filename = f"{sequence_name.lower()}_packet_{i+1:02d}_response.bin"
            with open(filename, "wb") as f:
                f.write(response)
            print(f"ðŸ’¾ Saved response to {filename}")
            
            # Check for special responses
            if len(response) >= 3 and response[:3] == bytes([0x01, 0x01, 0x01]):
                print("âš ï¸  Special response detected: 01:01:01 - might need PRE_INIT")
        
        time.sleep(0.2)  # Pause between commands
    
    print(f"\nðŸ“Š {sequence_name} Summary: {success_count}/{len(packets)} packets got responses")
    return responses

def continuous_capture(dev):
    """Continuously capture fingerprint data using REPEAT packets"""
    print(f"\n{'='*60}")
    print(f"ðŸ”„ CONTINUOUS CAPTURE MODE")
    print(f"Touch the sensor repeatedly...")
    print(f"Press Ctrl+C to stop")
    print(f"{'='*60}")
    
    try:
        capture_count = 0
        while True:
            print(f"\n--- Capture {capture_count + 1} ---")
            responses = try_packet_sequence(dev, REPEAT_PACKETS, f"CAPTURE_{capture_count + 1}")
            
            # Look for image data in responses
            for i, response in enumerate(responses):
                if response and len(response) > 1000:  # Large response likely contains image
                    filename = f"fingerprint_capture_{capture_count + 1}_{i}.bin"
                    with open(filename, "wb") as f:
                        f.write(response)
                    print(f"ðŸ–¼ï¸  Potential image data saved to {filename}")
            
            capture_count += 1
            time.sleep(1)  # Wait between captures
            
    except KeyboardInterrupt:
        print(f"\nðŸ›‘ Stopped after {capture_count} captures")

def main():
    print("ðŸ” EgisTec EH576 Fingerprint Scanner - EH575 Protocol Test")
    print("Based on libfprint EH575 driver initialization sequences")
    
    result = connect_device()
    if result is None:
        return
    
    dev, intf = result
    
    try:
        # Try POST_INIT first (normal startup)
        post_responses = try_packet_sequence(dev, POST_INIT_PACKETS, "POST_INIT")
        
        # Check if we need PRE_INIT (if we got 01:01:01 response)
        need_pre_init = False
        if len(post_responses) > 1 and post_responses[1]:
            if len(post_responses[1]) >= 3 and post_responses[1][:3] == bytes([0x01, 0x01, 0x01]):
                need_pre_init = True
        
        if need_pre_init:
            print("\nðŸ”„ Device needs PRE_INIT sequence...")
            try_packet_sequence(dev, PRE_INIT_PACKETS, "PRE_INIT")
            # Try POST_INIT again after PRE_INIT
            try_packet_sequence(dev, POST_INIT_PACKETS, "POST_INIT_RETRY")
        
        # Now try continuous capture
        continuous_capture(dev)
        
    finally:
        # Cleanup
        print("\nðŸ§¹ Cleaning up...")
        usb.util.release_interface(dev, intf.bInterfaceNumber)
        try:
            dev.attach_kernel_driver(intf.bInterfaceNumber)
        except:
            pass

if __name__ == "__main__":
    main()
